package main

/*
	Аллокация - это выделение памяти под данные в программе. В Go есть два основных места для аллокации:

	Стек (stack):
		Быстрое выделение памяти
		Память автоматически освобождается при выходе из функции (при выходе из stack frame, после передачи вызывающему stack frame)
		Используется для локальных переменных небольшого размера

	Куча (heap):
		Более медленное выделение памяти
		Память освобождается сборщиком мусора (garbage collector)
		Используется для больших объектов и данных, которые должны жить после выхода из функции
*/


type Reader interface { // Reader из пакета io
	Read(p []byte) (n int, err error)
	/*
			Read читает данные в p, но почему так именно передаем куда считыать,
		 	а не возвращаем считанное (как в Reader2) ?

			Потому что:
			1) Буфер p создается один раз в стеке или куче (зависит от размера)
			2) Переиспользуется многократно
			3) Нет новых аллокаций при каждом чтении
	*/
}

type Reader2 interface {
	Read() (p []byte, err error)
	/*
		почему не так? - потому что p ушло бы на кучу как только Read() ушла из стека


		Минусы:
		1) При каждом вызове создается новый слайс в куче
			Когда функция возвращает слайс, Go должен где-то разместить этот слайс и его базовый массив.
			Поскольку:
				а) Слайс должен существовать после выхода из функции
				б) Данные нужно вернуть вызывающему коду
		2) Каждый раз происходит новая аллокация памяти
			Cтандартный io.Reader принимает существующий буфер как параметр
			- это позволяет переиспользовать память и избежать постоянных аллокаций в куче.
		3) Сборщику мусора придется чистить неиспользуемые слайсы
	*/
}